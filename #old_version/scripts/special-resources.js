/*---------------------------------------------------------------------------Boston UniversityDept. of Computer Science, METcs575 Operating System Final ProjectRoundRobinCPU, FIFO by [Jan Horjus] Static-Priority, Dynamic-Priority, Shortest-Job-First by [Chao-Te Yang]---------------------------------------------------------------------------*/// Class RoundRobinCPU - a flexible round-robin CPU resource with configurable quantum and number of cores.function RoundRobinCPU(name, quantum, cores){     // We inherit from the Resource class. This is also where we pass values into the parent class constructor!    // this.prototype = new Resource(name);  <-- This line must be included after the full definition of the class. Here for referance.    Resource.call(this, name); // A javascript trick that allows you to call the parent class's constructor (since you normally don't get to).          // Now we have our own constructor code:    this.quantum = quantum !== undefined ? quantum : 100; // Default quantum is 100.    this.cores   = cores   !== undefined ? cores   : 1;   // Default number of cores is 1.    this.quantumsUsed = {}; // Will be populated by (pID:timeChargedToCurrentQuantum) key:value pairs.  Since the keys are all numbers we use []. (memory or performance risk??)        // Now the main functions that every resource has to overwrite: currentAllocations and notifyResourceClock.      this.notifyResourceClock = function(timePassed)    {        // Round Robin needs to decrement the remaining current quantum for every current allocation.         allocs = this.currentAllocations();        if (allocs !== undefined && allocs.length > 0){            for(var ii in allocs){                var procID = allocs[ii].pID;                // If no entry of time charged to a quantum for this pID exists, create it. Otherwise increment it.                if (this.quantumsUsed[procID] !== undefined){                    this.quantumsUsed[procID] += timePassed;                }                else{                    this.quantumsUsed[procID] = timePassed;                }                // If the process has reached the end of its quantum, move it to the back of the queue, and delete its charge entry.                if (this.quantumsUsed[procID] === this.quantum){                    var pos = this.requestInQueue(procID);                    var request = this.waitingQueue.splice(pos,1); // Splice should return the removed object...                    this.waitingQueue.push(request[0]);            // So that it can be pushed back on the end of the array.                    delete this.quantumsUsed[procID];                    print("DEBUG:P"+procID+" used up it's quantum on resource "+this.name+". Moved to back of queue.");                }                else if (this.quantumsUsed[procID] > this.quantum){                    print("***ERROR! Somehow P"+procID+" exceeded its quantum!");                }            }        }                // The second thing we need to do is prune the quantumsUsed list of any entries for processes that are no         // longer in the waitingQueue.          for(ii in this.quantumsUsed){            if (this.requestInQueue(parseInt(ii)) === -1){                delete this.quantumsUsed[ii];                print("DEBUG:P"+procID+"'s quantum charge entry pruned from "+this.name+". It must have released the resource voluntarily.");            }        }        //Don't need to increment the resourceClock in a inherited class.      }        this.currentAllocations = function()  //*    {		        // We return a number of allocations up to the number of cores configured or the number of outstanding requests.          retVal = [];        for (var ii = 0; ii < this.cores && ii < this.waitingQueue.length; ii++){            // We return those allocations to the processes at the front of the queue.             // The length of each allocation is equal to the remaining quantum for the process or the time requested - whichever is smaller.             var quantumAlreadyUsed = this.quantumsUsed[this.waitingQueue[ii].pID] !== undefined ? this.quantumsUsed[this.waitingQueue[ii].pID] : 0;            var timeTillPreemption = this.quantum - quantumAlreadyUsed //0 or none for non-preemptive            var timeToAllocate;            if (timeTillPreemption < this.waitingQueue[ii].quantum){                // The "process runs out of quantum" case.                 timeToAllocate = timeTillPreemption;            } else {                // The "process doesn't need a whole quantum" case.                 timeToAllocate = this.waitingQueue[ii].quantum;            }            retVal.push( new Allocation(this.name,                     this.waitingQueue[ii].pID,                     timeToAllocate,                     this.waitingQueue[ii].quantity,  //TODO: Actually respect quantity!                     timeTillPreemption) ); // This is a pre-emptive resource.              print("RRCPU \""+this.name+"\" allocating "+timeToAllocate+" cycles to P"+this.waitingQueue[ii].pID+".")        }        return retVal;    }    RoundRobinCPU.prototype = new Resource();   //*    //End of Class Simulator}// Default FIFO CPU// All default settingfunction FIFOCPU(name){     Resource.call(this, name);    FIFOCPU.prototype = new Resource(); }// Implementation of Static-Priority CPU (no preemption)function SPCPU(name){     Resource.call(this, name);	var flag = 0;  	    this.currentAllocations = function(){		var max_priority = 1000000;  // This is for calculating the highest priority		var max_pos = 0;	// Position in process list which has the highest priority		retVal = [];	// The return value		procTemp = [];	// Copy the process list in current waiting queue				var content=""; // Text content that will be displayed in web page		procArray = [];		procArray = ProcessManager.processes();  // procArray is a copy of process list				// Show the detailed and statistic information of each process		document.getElementById("sim-info").innerHTML = "<pre>Process     Arrival    Duration		Priority	WaitingTime     TurnaroundTime</pre></p></br>";		for(var s in procArray){			content += ("<p><pre>Process " + procArray[s].name + ":  "+ procArray[s].arrivalTime + 				"		" + procArray[s].duration + "		" + procArray[s].priority+				"		  " + procArray[s].getWaitDuration()+ "   			"+  "</pre></p></br>"); 		}		document.getElementById("info-content").innerHTML = content;		if(this.waitingQueue.length >0){			var timeToAllocate;			print("----> waitingQueue size = " + this.waitingQueue.length);						// Find out which process is in the waiting queue, and copy it into procTemp			for(var i in this.waitingQueue){ 				for(var ii in procArray){					if( procArray[ii].pID == this.waitingQueue[i].pID ){						procTemp.push(procArray[ii]);						print("MSG-1: waitingQueue[" + i + "]'s pID = " + this.waitingQueue[i].pID);						print("MSG-2: procTemp[" + i + "]'s name = " + procArray[ii].name);					}				}			}						// Flag = 0 only happens when all processes arrived at 0			for(var s in procTemp){				if( procTemp[s].arrivalTime !== 0){					flag = 1;				}			}						if(flag == 0){				// If all processes arrived at 0, simply allocate the resource to the process with highest priority				for(var j in procTemp){					if( procTemp[j].priority < max_priority){						// Find the process with highest priority						max_priority = procTemp[j].priority;						max_pos = j;						print("MSG-3: Max priority = " + max_priority);						print("MSG-4: Max pos = " + max_pos);					}				}				timeToAllocate = this.waitingQueue[max_pos].duration;				print("---> 1:Resource "+this.name+": Allocating "+timeToAllocate+" cycles to P"+this.waitingQueue[max_pos].pID + ", priority = " + max_priority);				retVal.push(new Allocation(this.name, this.waitingQueue[max_pos].pID, timeToAllocate, this.waitingQueue[max_pos].quantity));				return retVal;							}else if(flag == 1){				// First allocate the resource to the process starting at 0				timeToAllocate = this.waitingQueue[0].duration;				print("---> 2:Resource "+this.name+": Allocating "+timeToAllocate+" cycles to P"+this.waitingQueue[0].pID);				flag++;				retVal.push(new Allocation(this.name, this.waitingQueue[0].pID, timeToAllocate, this.waitingQueue[0].quantity));				return retVal;							}else{				// Now, allocate the resource to the process with highest priority				for(var j in procTemp){					if(procTemp[j].priority < max_priority){						max_priority = procTemp[j].priority;						max_pos = j;						print("-----> HIGHEST PRIORITY FOUND");					}				}				timeToAllocate = this.waitingQueue[max_pos].duration;				print("---> 3:Resource "+this.name+": Allocating "+timeToAllocate+" cycles to P"+this.waitingQueue[max_pos].pID + ", priority = " + max_priority);				retVal.push(new Allocation(this.name, this.waitingQueue[max_pos].pID, timeToAllocate, this.waitingQueue[max_pos].quantity));				return retVal;			}		}	}    SPCPU.prototype = new Resource();}// Implementation of Dynamic-Priority CPUfunction DPCPU(name){    Resource.call(this, name);	var flag = 0;	    this.currentAllocations = function(){				var max_priority = 1000000;		var max_pos = 0;		var content="";				retVal = [];		procArray = [];		procTemp = [];				procArray = ProcessManager.processes();		document.getElementById("sim-info").innerHTML = "<pre>Process     Arrival    Duration		Priority	WaitingTime     TurnaroundTime</pre></p></br>";		for(var s = 0; s < procArray.length; s++){			if(s == procArray.length-1){				content += ("<pre>" + procArray[s].name + "    	     "+ procArray[s].arrivalTime + "		" + procArray[s].duration + "		" + procArray[s].priority+				"	     	" + procArray[s].getWaitDuration()+ "		"+ (procArray[s].finishTime - procArray[s].arrivalTime) + "</pre></br>"); 			}else{				content += ("<pre>" + procArray[s].name + "    	     "+ procArray[s].arrivalTime + "		" + procArray[s].duration + "		" + procArray[s].priority+				"	     	" + procArray[s].getWaitDuration()+ "		"+procArray[s].getTurnAroundTime() + "</pre></br>"); 			}		}				document.getElementById("info-content").innerHTML = content;				if(this.waitingQueue.length >0){			var timeToAllocate;			print("----> waitingQueue size = " + this.waitingQueue.length);						//for(var i in procArray){ print(procArray[i].name + "'s priority = " + procArray[i].priority);}						for(var i in this.waitingQueue){ 				for(var ii in procArray){					if( procArray[ii].pID == this.waitingQueue[i].pID ){						procTemp.push(procArray[ii]);						print("MSG-1: waitingQueue[" + i + "]'s pID = " + this.waitingQueue[i].pID);						print("MSG-2: procTemp[" + i + "]'s name = " + procArray[ii].name);					}				}			}							// Allocate the resource to the first arrived process				if(flag == 0 ){					print("Flag = " + flag);					for(var s in procTemp){						if(procTemp[s].arrivalTime == 0)							max_pos = s;					}					print("Resource "+this.name+": Allocating "+timeToAllocate+" cycles to P"+ this.waitingQueue[max_pos].pID);					retVal.push(new Allocation(this.name, this.waitingQueue[max_pos].pID, timeToAllocate, this.waitingQueue[max_pos].quantity));					flag++;					return retVal;				}				else{					// Allocate the resource to the process with highest priority					print("Flag = " + flag);					for(var j in procTemp){						if( procTemp[j].priority < max_priority){							max_priority = procTemp[j].priority;							max_pos = j;							print("MSG-3: Max priority = " + max_priority);							print("MSG-4: Max pos = " + max_pos);						}					}					timeToAllocate = this.waitingQueue[max_pos].duration;					print("Resource "+this.name+": Allocating "+timeToAllocate+" cycles to P"+this.waitingQueue[max_pos].pID + ", priority = " + max_priority);					retVal.push(new Allocation(this.name, this.waitingQueue[max_pos].pID, timeToAllocate, this.waitingQueue[max_pos].quantity));					return retVal;				}		}		}    DPCPU.prototype = new Resource();}// Implementation of SJF (no preemption)function SJFCPU(name) {     Resource.call(this, name);	var flag = 0;    this.currentAllocations = function(){		var min_duration = 100000;		var min_pos = 0;		retVal = [];		procTemp = [];				var content="";		procArray = [];		procArray = ProcessManager.processes();		document.getElementById("sim-info").innerHTML = "<pre>Process     Arrival    Duration		Priority	WaitingTime     TurnaroundTime</pre></p></br>";		for(var s in procArray){			content += ("<pre>" + procArray[s].name + "    	     "+ procArray[s].arrivalTime + "		" + procArray[s].duration + "		" + procArray[s].priority+				"	     	" + procArray[s].getWaitDuration()+ "		"+procArray[s].getTurnAroundTime() + "</pre></br>"); 		}				document.getElementById("info-content").innerHTML = content;				if(this.waitingQueue.length >0){			var timeToAllocate;			print("----> waitingQueue size = " + this.waitingQueue.length);						//for(var i in procArray){ print(procArray[i].name + "'s priority = " + procArray[i].priority);}						for(var i in this.waitingQueue){ 				for(var ii in procArray){					if( procArray[ii].pID == this.waitingQueue[i].pID ){						procTemp.push(procArray[ii]);						print("MSG-1: waitingQueue[" + i + "]'s pID = " + this.waitingQueue[i].pID);						print("MSG-2: procTemp[" + i + "]'s name = " + procArray[ii].name);					}				}			}						for(var s in procTemp){				if( procTemp[s].arrivalTime !== 0){					flag = 1;				}			}						if(flag == 0){				for(var j in procTemp){					if( procTemp[j].duration < min_duration){						min_duration = procTemp[j].duration;						min_pos = j;						print("MSG-3: min duration = " + min_duration);						print("MSG-4: min pos = " + min_pos);					}				}				timeToAllocate = this.waitingQueue[min_pos].duration;				print("Resource "+this.name+": Allocating "+timeToAllocate+" cycles to P"+this.waitingQueue[min_pos].pID + ", duration = " + min_duration);				retVal.push(new Allocation(this.name, this.waitingQueue[min_pos].pID, timeToAllocate, this.waitingQueue[min_pos].quantity));				return retVal;			}else if(flag == 1){				timeToAllocate = this.waitingQueue[0].duration;				print("2: Resource "+this.name+": Allocating "+timeToAllocate+" cycles to P"+this.waitingQueue[0].pID);				retVal.push(new Allocation(this.name, this.waitingQueue[0].pID, timeToAllocate, this.waitingQueue[0].quantity));				flag++;				return retVal;			}else{				for(var j in procTemp){					if( procTemp[j].duration < min_duration){						min_duration = procTemp[j].duration;						min_pos = j;						print("MSG-5: min duration = " + min_duration);						print("MSG-6: min pos = " + min_pos);					}				}				timeToAllocate = this.waitingQueue[min_pos].duration;				print("Resource "+this.name+": Allocating "+timeToAllocate+" cycles to P"+this.waitingQueue[min_pos].pID + ", duration = " + min_duration);				retVal.push(new Allocation(this.name, this.waitingQueue[min_pos].pID, timeToAllocate, this.waitingQueue[min_pos].quantity));				return retVal;			}					}		}    SJFCPU.prototype = new Resource();}// Future improvement: More algorithms// Implementation of SJF with preemption (Shortest remaining time first)/*function SRTFCPU(name) {     Resource.call(this, name);    this.currentAllocations = function(){			}    SRTFCPU.prototype = new Resource();}*/$(function() {    ResourceManager.addType('RRCPU', 'Round-Robin CPU', 'CPU', RoundRobinCPU, [        {name: 'Quantum', value: '1', unit: 'ms', help: 'Maximum period to run one process before switching', numeric: true}    ]);	ResourceManager.addType('SPCPU', 'Static-Priority CPU (no preemption)', 'CPU', SPCPU, []);	ResourceManager.addType('DPCPU', 'Dynamic-Priority CPU', 'CPU', DPCPU, []);	ResourceManager.addType('SJFCPU', 'Shortest-Job-First CPU (no preemption)', 'CPU', SJFCPU, []);	//ResourceManager.addType('SRTFCPU', 'Shortest-Remaining-Time-First', 'CPU', SRTFCPU, []);	ResourceManager.addType('FIFOCPU', 'First-Come-First-Out CPU', 'CPU', FIFOCPU, []);});